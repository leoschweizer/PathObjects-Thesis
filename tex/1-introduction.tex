\chapter{Introduction}
\label{c:introduction}

Program comprehension is an essential requirement during software development.
During this process, developers construct a mental model that maps the features of a software system to their source code representation \cite{latoza_maintaining_2006}.
But while the programming languages and concepts developers use have evolved notably from eighty-column cards and assembler to object-oriented programming, the further development of established tools that are supposed to help in the understanding of software systems seemingly was not able to keep pace.

In other words, Diehl states that "programmers tend to adapt to the level of representation provided by the computer, instead of adapting the computer's representations to their perceptive abilities" \cite{diehl_software_2007}.
As a result, there is a huge gap between the metaphors and concepts used during development, and the representation of program behavior tools provide.

Conventional symbolic debuggers that commonly are included in object-oriented development environments constitute a paragon for this phenomenon.
While developers design a system with objects and their interactions in mind, the information presentation of those debuggers is centered around the call stack of the current execution.
This presentation rather conforms to the processes on machine level than to the object-oriented concepts...
It is not particularly suited to answer questions that often arise during development.

Consequently, it is reported that developers spend up to 60\% of the software engineering effort on building a satisfactory understanding of the system at hand \cite{corbi_program_1989, basili_evolving_1997, ducasse_class_2005, rothlisberger_feature_2007, cornelissen_execution_2008}.
And not only software developers would benefit if the effort that has to be spent on program comprehension could be reduced significantly.
One could argue that reducing this necessary evil would allow developers to focus on productive tasks,... blubb blubb \todo{...}.

proposed solution \todo{...}

The question is why such an information presentation has not been established yet.
The problem is that in order to visualize program behavior at the abstraction level of objects, the application of dynamic analysis techniques is inevitable.
This means that information about the behavior of a program has to be collected during actual executions of the program under investigation, as it is impossible to derive this kind of information from the source code alone.
Source code models the structure of a system in terms of classes and their relationships rather than its actual behavior.
But due to object-oriented concepts like polymorphism and late binding, the actual participating objects of a computation and the messages that are exchanged between them are only known at runtime.

\todo[inline]{Context}
\todo[inline]{Problem}
\todo[inline]{Significance -> Research Question}
\begin{quote}
Can the behavior of software systems be presented at the abstraction level of objects while maintaining immediacy and perceiveability?
\end{quote}
\todo[inline]{Solution}

\section{Contributions}
\label{s:contributions}

\begin{description}[leftmargin=0pt]
\item[First Contribution]
...
\end{description}



\section{Thesis Structure}
The remainder of this thesis is structured as follows:
Chapter \ref{c:Background} gives an overview of the background of program comprehension, of techniques that are typically used to collect the runtime information required for the analysis of object interactions, and of established diagram notations that cover the state of objects and their interactions.
The chapter concludes with a summary of the problems of the presented methods and techniques and their inadequacy for our objectives.
Chapter \ref{c:approach} outlines our approach to the solution of those problems.
Chapter \ref{c:implementation} presents \textsc{PathObjects}, our prototypical implementation of our approach for the Squeak Smalltalk environment.
Chapter \ref{c:discussion} gives an overview over the runtime performance and space consumption of our approach and shows that both are sufficient to provide an immediate user experience.
The user study that was performed to validate the perceivability of our information presentation and its effectiveness in terms of aiding in program comprehension is presented.
The chapter concludes with an overview of the limitations of our approach and an analysis of the applicability to other programming languages and environments.
Chapter \ref{c:relatedwork} shows related work in the areas of trace visualization, debugging, and education and relates the presented approaches to \textsc{PathObjects}.
Chapter \ref{c:conclusions} concludes with an outlook on possible future work and a summary of the research problem, our proposed solution, and the results of our research.