\chapter{Introduction}
\label{c:introduction}

Program comprehension is an integral part of the software development process.
During this process, developers construct a mental model that maps the behavior of a software system to its source code representation \cite{latoza_maintaining_2006}.
But while the programming languages and concepts developers use have evolved notably from eighty-column cards and assembly language to object-oriented programming, the further development of established tools that are supposed to help in the understanding of software systems seemingly was unable to keep pace in two respects.

Diehl describes the first and prevalent issue as follows: "programmers tend to adapt to the level of representation provided by the computer, instead of adapting the computer's representations to their perceptive abilities" \cite{diehl_software_2007}.
In other words, the way program behavior is presented to developers is characterized by the low level concepts computers operate on, instead of the high level concepts that are used to design software systems.
The result of this phenomenon is a huge gap between the metaphors and concepts used during development, and the representation of program behavior tools provide.

Conventional symbolic debuggers that commonly are included in object-oriented development environments constitute an example par excellence.
While developers design a system with objects and their interactions in mind, the information presentation of those debuggers is centered around the call stack of the current execution.
This presentation rather conforms to the processes on machine level than to the object-oriented concepts used during the development of the system.
Consequently, it is not particularly suited to answer questions about object-oriented programs straightforwardly.
For instance, the presentation of the call stack does not help to identify which objects are involved in the current computation, at which other parts of the call stack those objects reappear, or which other objects they are communicating with.

The second issue is related to the questions developers frequently ask during development and the information that is required to answer these questions \cite{sillito_asking_2008, latoza_hard--answer_2010, abi-antoun_questions_2010}.
Aspects covered by such questions range from information that is typically maintained by version control systems, like which recent changes have been made to specific parts of the system, to information that commonly has to be collected with the help of external tools, like profiling information.
Beyond that, questions about the actual program behavior play an important role when developers are confronted with the source code of an unknown system.
However, there is no established combined view on information from these different dimensions, and developers have to collect it manually from the different tools.
This can be a tedious and time consuming task.

\section{Problem}
Consequently, it is reported that developers spend up to 60\% of the software engineering effort on building a satisfactory understanding of the system at hand \cite{corbi_program_1989, basili_evolving_1997, ducasse_class_2005, rothlisberger_feature_2007, cornelissen_execution_2008}.
And not only software developers would benefit if the effort that is spent on program comprehension could be reduced significantly.
Speeding up the activity of understanding a software system enables developers to eliminate defects faster.
In turn, this would on the one hand reduce the costs of software maintenance - which are reported to account for 40\%-80\% of the total costs \cite{glass_frequently_2001} - and on the other hand increase the overall quality of the system.
Assisting in the understanding of a program also eases the process of adding new features.
Again, this activity accounts for a significant share of the costs of software maintenance.
As a result, even the end-users could benefit from a reduction of the program comprehension effort in the form of high-quality and feature-rich software systems.

The way in which information is presented plays an important role in the process of human reasoning and thus in the construction of a mental map \cite{diehl_software_2007}.
Hence it seems reasonable that a reduction of the gap between the presentation of information of a program's behavior and the concepts that are used at design time would help to reduce the amount of time developers have to spend on program comprehension.
If an information presentation at the abstraction level of objects and their interactions could be provided, developers no longer would have to map the low level concepts provided by development tools to the high level concepts used mentally.

This situation raises the question why such an information presentation has not been established so far.
The problem is that in order to visualize program behavior at the abstraction level of objects, the application of dynamic analysis techniques is inevitable.
This means that information about the behavior of a program has to be collected during actual executions of the program under investigation, because it is impossible to derive this kind of information from the source code alone.
The latter models the structure of a system in terms of classes and their relationships rather than its actual behavior.
But due to object-oriented concepts like polymorphism and late binding, the objects that are actually participating in a computation and the messages that are exchanged between them are only known at runtime.

However, dynamic analysis has four closely related problems that hinder its broad application down to the present day.
First, to collect runtime information, the execution of a program has to be manipulated in a way that traces of the execution can be generated.
Typically, this is done by instrumentation at the source code or byte code level or through the utilization of debug interfaces.
The side effect of such manipulations is that they often decelerate the execution speed of a program excessively.
The runtime costs of instrumentation are reported to range from around 10-15 times the costs of standalone executions up to 115 times in worst case scenarios \cite{pothier_scalable_2007, karran_synctrace:_2013}.
Consequently, developers have to wait a significant amount of time for tracing runs to finish.
As a result, developers have to wait until they can start analyzing traces, thereby increasing the amount of time required for program comprehension.

The second problem is the huge amount of data that arises even during short executions of software systems.
For instance, Karran et al. report that an execution of the Firefox browser and subsequent loading of a Google result page yield 3GB of trace data \cite{karran_synctrace:_2013}.
Pothier et al. state that a tracing session of the Eclipse IDE that involved the creation of classes, editing of source code, and a step-by-step execution with the debugger resulted in a trace of 33GB \cite{pothier_scalable_2007}.
This issue is so prevalent that the topic of trace size reduction has become a research area of its own.

As a result, the third problem turns out to be the time that is required to analyze and visualize traces.
Due to the huge amount of data, they often cannot be kept in main memory, which slows down the process further.
Again, time that developers have to wait for results is time that slows down the process of program comprehension and thus should preferably be spent on more productive tasks.

The fourth and last problem also is a direct result of overly large traces.
The visualizations of traces themselves grow proportional to the size of the traces.
This makes it increasingly difficult for the observer to perceive and comprehend the actual information which is encoded in the visualization.

As pointed out, program comprehension and dynamic analysis are both time consuming tasks on their own.
Beyond that, dynamic analysis does not necessarily ease the process of program understanding due to the sheer amount of data that is presented to the observer.
This seems to imply that the latter is ill-suited to help in the reduction of the time spent on comprehending the system at hand.
Hence the main research question that is tackled in this thesis is:

\begin{quote}
1) Can the behavior of software systems be presented at the abstraction level of objects while maintaining immediacy and perceivability?
\end{quote}

Since it is only an assumption that such an information presentation would actually help developers to understand the software system at hand better, the second research question we derive is:

\begin{quote}
2) Can such an information presentation actually aid in the process of program comprehension?
\end{quote}

\section{Revealing Object Interactions with \textsc{PathObjects}}

Perscheid et al. have conducted research on how to cope with some of the shortcomings of dynamic analysis and have proposed \emph{Step-wise Run-time Analysis} as lightweight alternative to conventional tracing approaches \cite{perscheid_immediacy_2010}.
The fundamental idea is to use test cases as reproducible entry points into the behavior of specific usage scenarios of a system.
Instead of collecting potentially useful information in its entirety up front, a shallow analysis is performed during the first tracing run that only yields the bare minimum of data required for the reconstruction of test executions.
During the inspection of such a shallow trace, the developer can perform refinement runs to collect further information of interest, such as the internal state of objects or the specific values that are used as arguments.
As a result, the approach enables immediacy and displays only that information to the developer that is actually relevant.
However, this solution still lacks an appropriate information representation at the abstraction level of objects.
The primary purpose of \textsc{PathFinder}, the tool that is provided to present execution traces to the developer, is back-in-time debugging.
Therefore, it offers visualizations in the form of call trees.
Again, this presentation conforms to the technical procedures rather than being guided by the high level concepts of object-orientation.

This work proposes to tackle the two main problems identified above: first, traditional development tools tend to adapt the low level concepts of computers instead of adapting the high level concepts used during development.
However, an information representation of objects and their interactions is hard to provide in a beneficial manner due to the scalability issues of dynamic analysis techniques.
Therefore, we propose to extend the \emph{Step-wise Run-time Analysis} tracing technique in a way that preserves its immediate character and low memory footprint while at the same time making it suitable for the reconstruction of object interactions.
Based on this extension, we further propose an interactive information presentation at the abstraction level of objects that aims at avoiding the cognitive overload caused by existing dynamic analysis tools.
The information requirements developers have during the process of program comprehension constitute the second main problem.
We show how information from various domains can be integrated into the visualization of object interactions with the help of user defined information layers.
Thus, the need to manually collect information from a multitude of separate tools can be eliminated.

\todo[inline]{introduce contributions}

\begin{itemize}
\renewcommand{\labelitemiv}{$\ast$}

\item \textbf{An Interactive Diagram Notation for Object Interactions} We propose an interactive way of diagramming object states and interactions that allows users to navigate through program executions, to explore object states and relationships, to focus on specific parts of interest, and to augment the displayed information through user-defined information layers.

\item \textbf{A Lightweight Approach for Tracing Object Interactions} We present an extension of the \emph{Step-wise Run-time Analysis} approach that allows to reconstruct object interactions from traces while maintaining immediacy and a low memory footprint.

\item \textbf{A Prototypic Implementation for Squeak/Smalltalk} We validate the applicability of our approach with the help of an implementation for the Squeak development environment.
\end{itemize}

Furthermore, we use this prototype to verify that our proposed solution actually can help developers in the process of program comprehension with the help of a user evaluation. \todo{summarize results}

\section{Thesis Structure}
The remainder of this thesis is structured as follows:
Chapter \ref{c:Background} looks into the background of program comprehension and into techniques that are typically used to collect the runtime information required for the analysis of object interactions.
Furthermore, established diagram notations that cover the state of objects and their interactions are presented.
The chapter concludes with a discussion of the presented techniques and their inadequacy for our objectives.
Chapter \ref{c:approach} describes \textsc{PathObjects}, which represents our proposed solution to those problems.
Chapter \ref{c:implementation} presents a prototypical implementation of \textsc{PathObjects} for the Squeak/Smalltalk environment and describes the required extensions of the \textsc{PathTools} framework.
Chapter \ref{c:discussion} evaluates our approach with the help of a performance analysis and a user evaluation. 
The chapter concludes with a discussion of the limitations of our approach and its applicability to other programming languages and environments.
Chapter \ref{c:relatedwork} shows related work in the areas of trace visualization, debugging, and education.
Chapter \ref{c:conclusions} concludes this work and presents reasonable directions for future research.