\chapter{Introduction}
\label{c:introduction}

Program comprehension is an essential requirement during software development.
During this process, developers construct a mental model that maps the features of a software system to their source code representation \cite{latoza_maintaining_2006}.
But while the programming languages and concepts developers use have evolved notably from eighty-column cards and assembler to object-oriented programming, the further development of established tools that are supposed to help in the understanding of software systems seemingly was unable to keep pace.

In other words, Diehl states that "programmers tend to adapt to the level of representation provided by the computer, instead of adapting the computer's representations to their perceptive abilities" \cite{diehl_software_2007}.
As a result, there is a huge gap between the metaphors and concepts used during development, and the representation of program behavior tools provide.

Conventional symbolic debuggers that commonly are included in object-oriented development environments constitute a paragon for this phenomenon.
While developers design a system with objects and their interactions in mind, the information presentation of those debuggers is centered around the call stack of the current execution.
This presentation rather conforms to the processes on machine level than to the object-oriented concepts...
Consequently, it is not particularly suited to answer questions that often arise during development of object-oriented systems.
For instance, the presentation of the call stack does not help to identify which objects are involved in the current computation, at which other parts of the call stack those objects reappear, or which other objects they are communicating with.

Consequently, it is reported that developers spend up to 60\% of the software engineering effort on building a satisfactory understanding of the system at hand \cite{corbi_program_1989, basili_evolving_1997, ducasse_class_2005, rothlisberger_feature_2007, cornelissen_execution_2008}.
And not only software developers would benefit if the effort that has to be spent on program comprehension could be reduced significantly.
One could argue that reducing this necessary evil would allow developers to focus on productive tasks,... blubb blubb \todo{...}.

It seems reasonable that a reduction of the gap between the presentation of information of a program's behavior and the concepts that are used at design time would help to reduce the amount of time developers have to spend on program comprehension.
If an information presentation at the abstraction level of objects and their interactions could be provided, developers no longer would have to map the low level concepts provided by development tools to the high level concepts used mentally.

The question is why such an information presentation has not been established so far.
The problem is that in order to visualize program behavior at the abstraction level of objects, the application of dynamic analysis techniques is inevitable.
This means that information about the behavior of a program has to be collected during actual executions of the program under investigation, as it is impossible to derive this kind of information from the source code alone.
Source code models the structure of a system in terms of classes and their relationships rather than its actual behavior.
But due to object-oriented concepts like polymorphism and late binding, the actual participating objects of a computation and the messages that are exchanged between them are only known at runtime.

Dynamic analysis has four closely related problems that hinder its broad application down to the present day.
First, to collect runtime information, the execution of a program has to be manipulated in a way that traces of the execution can be generated.
Typically this is done by instrumentation at the source code or byte code level or through the utilization of debug interfaces.
The side effect of this manipulation is that it often decelerates the time required to run a program excessively.
Consequently, developers have to wait a significant amount of time before they can start analyzing the traces, which in turn increases the amount of time required for comprehending the program.
The second problem is the huge amount of data that arises even during short executions of complex software systems.
For instance, it is reported that ...
This issue is so prevalent that the question how the size of such traces can be reduced  has become a research area of its own.
As a result, the third problem turns out to be the time that is required to analyze and visualize traces.
Due to the huge amount of data, they often can not be kept in main memory, which slows down the process further.
Again, time that developers have to wait for results is time that slows down the process of program comprehension and thus should preferably be spent on more productive tasks.
The fourth and last problem also is a direct result of outsized traces.
The visualization of a trace itself also grows with the size of the trace.
This makes it increasingly difficult for the observer to perceive and comprehend the actual information which is encoded in the visualization.

\section{Research Questions}
As pointed out, program comprehension and dynamic analysis are both time consuming tasks on their own.
Beyond that, dynamic analysis does not necessarily ease the process of program understanding due to the sheer amount of data that is presented to the observer.
This seems to imply that the latter are ill-suited to help in the reduction of the time spent on comprehending the system at hand.


\begin{quote}
Can the behavior of software systems be presented at the abstraction level of objects while maintaining immediacy and perceivability?
\end{quote}
\begin{quote}
Can such an information presentation actually aid in the process of program comprehension?
\end{quote}

Perscheid et al. have conducted preliminary research on how to cope with the shortcomings of dynamic analysis and have proposed \emph{Step-wise Run-time Analysis} as lightweight alternative to conventional tracing approaches \cite{perscheid_immediacy_2010}.
The fundamental idea is to use test cases as reproducible entry points ...
Instead of collecting potentially useful information in its entirety up front, a shallow analysis is done during the first tracing run that yields only the bare minimum of data that is required to reconstruct the test execution.
During the inspection of such a shallow trace, the developer can perform refinement runs to collect further information of interest, like the internal state of objects or the concrete values that are used as arguments.
As a result, the approach enables immediacy and displays only that information to the developer that is actually relevant.
But this solution still lacks an appropriate information representation at the abstraction level of objects.



\section{Contributions}
\label{s:contributions}

\paragraph{A Lightweight Approach of Tracing Object Interactions}
\paragraph{An Interactive Diagram Notation for Object Interactions}
\paragraph{A Prototypic Implementation for Squeak Smalltalk}

\section{Thesis Structure}
The remainder of this thesis is structured as follows:
Chapter \ref{c:Background} gives an overview of the background of program comprehension, of techniques that are typically used to collect the runtime information required for the analysis of object interactions, and of established diagram notations that cover the state of objects and their interactions.
The chapter concludes with a summary of the problems of the presented methods and techniques and their inadequacy for our objectives.
Chapter \ref{c:approach} outlines our approach to the solution of those problems.
Chapter \ref{c:implementation} presents \textsc{PathObjects}, our prototypical implementation of our approach for the Squeak Smalltalk environment.
Chapter \ref{c:discussion} gives an overview over the runtime performance and space consumption of our approach and shows that both are sufficient to provide an immediate user experience.
The user study that was performed to validate the perceivability of our information presentation and its effectiveness in terms of aiding in program comprehension is presented.
The chapter concludes with an overview of the limitations of our approach and an analysis of the applicability to other programming languages and environments.
Chapter \ref{c:relatedwork} shows related work in the areas of trace visualization, debugging, and education and relates the presented approaches to \textsc{PathObjects}.
Chapter \ref{c:conclusions} concludes with an outlook on possible future work and a summary of the research problem, our proposed solution, and the results of our research.