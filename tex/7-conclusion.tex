\chapter{Conclusions}
\label{c:conclusions}

\section{Summary}

\section{Future Work}

\paragraph{Pattern Recognition} Many trace visualization approaches that cover complete program executions employ pattern recognition techniques to reduce the traces to a manageable size (cf. Chapter \ref{c:relatedwork}).
While our approach of the utilization of test cases as representative program executions in conjunction with Step-wise Run-time Analysis mostly solves the trace size scalability issue in terms of processing time and memory consumption, some test cases are still too large to serve as foundations of comprehensible scenarios.
However, our observations are that the traces of large test cases are often repetitive in nature. Commonly, the same set of operations is performed in the same order on different objects.
Recurring instances of such execution patterns could be omitted, presenting only relevant instances to the user, and thus avoiding cognitive overload.
In this regard, the execution structure of such test cases might be particularly advantageous for the application of pattern detection techniques.
The suitability of such an approach could be the subject of further research.

\paragraph{Object Pooling} Due to the reasons depicted in Section \todo{missing ref}, collections of objects are flattened and all members of a collection, but not the collection object itself is displayed in an interaction diagram. However, some test cases involve iterations over rather large collections.
For instance, a test of the \textsc{DicThesaurusRex} project covering the synonym search functionality involves dozens of synonym objects, which excessively bloat the visualization without much added value, since the same operation is performed on each instance.
In such cases, it might be favorable to depict only one representative object instead of the whole collection.
In conjunction with above mentioned pattern recognition techniques, iterations of that kind could be reduced to the depiction of one single run.
In a broader context, it is also conceivable that not only the pooling of objects within collections, but objects of the same kind in general could have beneficial effects on the perceivability of interaction diagrams.

\paragraph{Advanced Querying} The keyword-based search engine in it's current form allows to answer questions like "when is an object used (next)?", "where is a specific method called?" or "where are instances of a specific class used?".
A more sophisticated search functionality with a dedicated query language - be it textual or graphical - would be desirable.
Three categories of questions such a query language could tackle are apparent.
The first category are queries over the message graph or call tree respectively.
For instance, those could include "when is a specific message sent to a specific object" or "which messages are follow-up messages of a specific one".
The second category consists of questions about the object or reference graph.
One could ask questions like "at which point in time does a specific object obtain or release a reference to another object?" or "which objects retain references on a specific object at a given point of time?".
The third and last category are questions about object state and state changes.
Ko and Myers have shown with \textsc{Whyline} that this area can very well be covered by a graphical query "editor" \cite{ko_debugging_2008}.
Such an approach could also be integrated into \textsc{PathObjects}.

\paragraph{Entry Points} -> still intuition \& trial and error

\paragraph{Visualization of Testsuites} -> not only test-cases, broader context

\paragraph{Extension to Concurrent Systems} (eher nicht)

\paragraph{Configuration of Metrics} (eher nicht)